salut, dans mon projet chat securisé basé sur le chiffrement de bout en bout et l'authentification multifacteur,  j'ai integré nextauth pour l'inscription et la connexion, mais je n'ai pas encore fini de mettre a jour les autres api et les composants, voici nextauth:

import NextAuth, { AuthOptions } from 'next-auth';
import CredentialsProvider from 'next-auth/providers/credentials';
import { PrismaClient } from '@prisma/client';
import { authService } from '@/services/authService';

const prisma = new PrismaClient();

export const authOptions: AuthOptions = {
    providers: [
        CredentialsProvider({
            name: 'Credentials',
            credentials: {
                email: { label: "Email", type: "email" },
                password: { label: "Password", type: "password" }
            },
            async authorize(credentials) {
                if (!credentials?.email || !credentials?.password) {
                    throw new Error('Email et mot de passe requis');
                }

                const user = await prisma.user.findUnique({
                    where: { email: credentials.email }
                });

                if (!user) {
                    throw new Error('Utilisateur non trouvé');
                }

                const isPasswordValid = await authService.verifyPassword(
                    credentials.password,
                    user.hashedPassword
                );

                if (!isPasswordValid) {
                    throw new Error('Mot de passe incorrect');
                }

                if (user.isTwoFactorEnabled) {
                    return {
                        id: user.id.toString(),
                        email: user.email,
                        requires2FA: true,
                        username: user.username
                    };
                }

                return {
                    id: user.id.toString(),
                    email: user.email,
                    name: user.username,
                    username: user.username
                };
            }
        })
    ],
    callbacks: {
        async jwt({ token, user }) {
            if (user) {
                token.id = user.id;
                token.requires2FA = user.requires2FA;
            }
            return token;
        },
        async session({ session, token }) {
            if (session.user) {
                session.user.id = token.id;
                session.user.requires2FA = token.requires2FA;
            }
            return session;
        }
    },
    pages: {
        signIn: '/components/login',
        error: '/components/login',
    },
    session: {
        strategy: 'jwt',
    },
};

export default NextAuth(authOptions);

_app.tsx:
// These styles apply to every route in the application
import '@/styles/globals.css'
import type { AppProps } from 'next/app'

export default function App({ Component, pageProps }: AppProps) {
  return <Component {...pageProps} />
}

chat.tsx:
/* eslint-disable react-hooks/exhaustive-deps */
'use client';

import { useState, useEffect } from 'react';
import { useRouter } from 'next/router';
import { encryptionService } from '@/services/encryptionService';
import { io, Socket } from 'socket.io-client';

interface Conversation {
  id: number;
  recipientId: number;
  recipientUsername: string;
  recipientPublicKey: string;
  messages?: Message[];
}

interface Message {
  id: number;
  senderId: number;
  receiverId: number;
  encryptedContent: string;
  encryptedContentCU: string;
  createdAt: string;
}

export default function Chat() {
  const [socket, setSocket] = useState<Socket | null>(null);
  const [conversations, setConversations] = useState<Conversation[]>([]);
  const [selectedConversation, setSelectedConversation] = useState<Conversation | null>(null);
  const [message, setMessage] = useState('');
  const [newRecipient, setNewRecipient] = useState('');
  const [error, setError] = useState('');
  const [currentUserId, setCurrentUserId] = useState(0);
  const router = useRouter();

  // Initialisation de Socket.IO
  useEffect(() => {
    const token = localStorage.getItem('token');
    if (!token) {
      router.push('/login');
      return;
    }

    // Connexion au serveur Socket.IO
    const newSocket = io(process.env.NEXT_PUBLIC_SOCKET_URL || 'http://localhost:3001', {
      auth: {
        token
      }
    });

    // Écoute des événements Socket.IO
    newSocket.on('connect', () => {
      console.log('Connected to Socket.IO server');
    });

    newSocket.on('new_message', (newMessage: Message) => {
      if (selectedConversation && newMessage.senderId === selectedConversation.recipientId) {
        setSelectedConversation(prev => {
          if (!prev) return prev;
          return {
            ...prev,
            messages: [...(prev.messages || []), newMessage]
          };
        });
      }
    });

    newSocket.on('conversation_created', (newConversation: Conversation) => {
      setConversations(prev => [...prev, newConversation]);
    });

    setSocket(newSocket);

    // Nettoyage à la déconnexion
    return () => {
      newSocket.close();
    };
  }, []);

  useEffect(() => {
    fetchCurrentUser();
    fetchConversations();
    fetchKeys();
  }, []);

  const fetchKeys = async () => {
    const token = localStorage.getItem('token');
    if (!token) {
      router.push('/login');
      return;
    }

    try {
      const res = await fetch('/api/get-keys', {
        headers: { Authorization: `Bearer ${token}` },
      });
      const data = await res.json();
      if (res.ok) {
        localStorage.setItem('privateKey', data.privateKey);
        console.log('Private key retrieved and stored');
      } else {
        setError(data.message);
      }
    } catch (error) {
      console.error('Error fetching keys:', error);
      setError('Une erreur est survenue lors de la récupération des clés');
    }
  };

  const fetchCurrentUser = async () => {
    const token = localStorage.getItem('token');
    if (!token) {
      router.push('/login');
      return;
    }

    try {
      const res = await fetch('/api/current-user', {
        headers: { Authorization: `Bearer ${token}` },
      });
      const data = await res.json();
      if (res.ok) {
        setCurrentUserId(data.userId);
      } else {
        setError(data.message);
      }
    } catch (error) {
      setError('Une erreur est survenue lors de la récupération des informations utilisateur: ' + error);
    }
  };

  const fetchConversations = async () => {
    const token = localStorage.getItem('token');
    if (!token) {
      router.push('/login');
      return;
    }

    try {
      const res = await fetch('/api/conversation', {
        headers: { Authorization: `Bearer ${token}` },
      });
      const data = await res.json();
      if (res.ok) {
        setConversations(data.conversations);
      } else {
        setError(data.message);
      }
    } catch (error) {
      setError('Une erreur est survenue lors de la récuperation des conversations: ' + error);
    }
  };

  const sendMessage = async () => {
    if (!selectedConversation || !message || !socket) return;

    const token = localStorage.getItem('token');
    const privateKey = localStorage.getItem('privateKey');

    if (!token || !privateKey) {
      router.push('/login');
      return;
    }

    try {
      const encryptedForSender = encryptionService.encryptSymmetric(message, privateKey);
      const encryptedForReceiver = encryptionService.encryptAsymmetric(
        message,
        selectedConversation.recipientPublicKey
      );

      // Émission du message via Socket.IO
      socket.emit('send_message', {
        conversationId: selectedConversation.id,
        receiverId: selectedConversation.recipientId,
        encryptedContent: encryptedForReceiver,
        encryptedContentCU: encryptedForSender,
      });

      setMessage('');
    } catch (error) {
      console.error('Error in sendMessage:', error);
      setError('Une erreur est survenue lors de l\'envoi du message: ' + error);
    }
  };

  const decryptMessage = (message: Message) => {
    const privateKey = localStorage.getItem('privateKey');
    if (!privateKey) {
      router.push('/login');
      return 'Erreur: Clé privée non disponible';
    }

    try {
      const formattedPrivateKey = `-----BEGIN PRIVATE KEY-----\n${privateKey}\n-----END PRIVATE KEY-----`;

      if (message.senderId === currentUserId) {
        return encryptionService.decryptSymmetric(message.encryptedContentCU, formattedPrivateKey);
      } else {
        return encryptionService.decryptAsymmetric(message.encryptedContent, formattedPrivateKey);
      }
    } catch (error) {
      console.error('Erreur de déchiffrement:', error);
      return 'Message chiffré';
    }
  };

  const fetchMessages = async (conversationId: number) => {
    const token = localStorage.getItem('token');
    if (!token) {
      router.push('/login');
      return;
    }

    try {
      const res = await fetch(`/api/messages?conversationId=${conversationId}`, {
        headers: { Authorization: `Bearer ${token}` },
      });
      const data = await res.json();
      if (res.ok && selectedConversation) {
        setSelectedConversation({ ...selectedConversation, messages: data.messages });
      } else {
        setError(data.message);
      }
    } catch (error) {
      setError('Une erreur est survenue lors de la récuperation des messages: ' + error);
    }
  };

  const createNewConversation = async () => {
    const token = localStorage.getItem('token');
    if (!token || !socket) {
      router.push('/login');
      return;
    }

    try {
      // Émission de l'événement de création de conversation via Socket.IO
      socket.emit('create_conversation', { recipientUsername: newRecipient });
      setNewRecipient('');
    } catch (error) {
      setError('Une erreur est survenue lors de la création de la nouvelle conversation:' + error);
    }
  };

  useEffect(() => {
    if (selectedConversation) {
      fetchMessages(selectedConversation.id);

      // Rejoindre la salle de conversation
      socket?.emit('join_conversation', selectedConversation.id);
    }
  }, [selectedConversation]);

  // Le reste du JSX reste inchangé
  return (
    <div className="flex min-h-screen bg-gray-100">
      <div className="h-screen w-1/4 overflow-y-hidden border-r bg-white">
        <h2 className="p-4 text-xl font-bold">Conversations</h2>
        <ul>
          {conversations.map((conv) => (
            <li
              key={conv.id}
              className="cursor-pointer p-4 hover:bg-gray-100"
              onClick={() => setSelectedConversation(conv)}
            >
              {conv.recipientUsername}
            </li>
          ))}
        </ul>
        <div className="p-4">
          <input
            type="text"
            value={newRecipient}
            onChange={(e) => setNewRecipient(e.target.value)}
            className="w-full rounded border p-2 px-4"
            placeholder="Nouveau déstinataire (Nom d'utilisateur)"
          />
          <button
            onClick={createNewConversation}
            className="mt-2 w-full rounded bg-green-500 px-4 py-2 text-white"
          >
            Nouvelle conversation
          </button>
        </div>
      </div>
      <div className="flex h-screen w-3/4 flex-col overflow-y-hidden">
        {selectedConversation ? (
          <>
            <div className="flex-1 overflow-y-auto p-4">
              {selectedConversation.messages && selectedConversation.messages.map((msg) => (
                <div key={msg.id} className={`mb-4 ${msg.senderId === selectedConversation.recipientId ? 'text-left' : 'text-right'}`}>
                  <p className="inline-block rounded-lg bg-blue-500 p-2 text-white">
                    {decryptMessage(msg)}
                  </p>
                </div>
              ))}
            </div>
            <div className="bg-white p-4">
              <input
                type="text"
                value={message}
                onChange={(e) => setMessage(e.target.value)}
                className="w-full rounded border p-2"
                placeholder="Taper un message..."
                onKeyPress={(e) => e.key === 'Enter' && sendMessage()}
              />
              <button
                onClick={sendMessage}
                className="mt-2 rounded bg-blue-500 px-4 py-2 text-white"
              >
                Envoyer
              </button>
            </div>
          </>
        ) : (
          <div className="flex flex-1 items-center justify-center">
            <p className="text-gray-500">Choisir une conversation</p>
          </div>
        )}
      </div>
      {error && (
        <div className="absolute inset-x-0 bottom-0 bg-red-500 p-2 text-center text-white">
          {error}
        </div>
      )}
    </div>
  );
}
